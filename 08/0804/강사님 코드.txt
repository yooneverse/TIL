##Gravity

# 가로 칸의 개수
N = int(input())
 
# 각 상자의 높이
lst = list(map(int, input().split()))
 
# 0번째 상자 탑에서 최대 낙차는?
# 1번째 상자 탑에서 최대 낙차는?
# 2번째 상자 탑에서 최대 낙차는?
# ...
# n-1번째 상자 탑에서 최대 낙차는?
 
# 상자 탑들 중에서 낙차가 가장 큰 상자의 낙차는 얼마일까?
# 상자탑에서 맨 위를 제외한 나머지 상자는 고려할 필요xxx
# 뒤집은 결과를 미리 생각해보면 맨 위쪽 상자가 낙차가 제일 높을것이기 때문
 
# 우리가 구하고자 하는 값 => 낙차중에 최대값
max_drop = 0
 
# 모든 상자 탑의 낙차를 구하기 위해 반복문 사용
for i in range(N):
    # i번째 상자탑(i는 상자탑의 인덱스)에서 최대 낙차 구하기
    # 상자의 높이 h => i번째 상자탑의 높이
    h = lst[i]
 
    # 낙차를 구하는 식
    # 가로 칸의 수(N) - i번 상자탑과 왼쪽 벽과의 거리(i+1)
    # - i번 상자탑의 높이보다 같거나 큰 오른쪽에 있는 상자탑의 개수(high_count)
    # i번 상자탑에서의 최대 낙차 = N - (i+1) - high_count
 
    # high_count 구하기
    high_count = 0
    # i번 상자탑의 오른쪽에 있는 상자탑의 높이를 전부 확인
    # 반복의 시작점과 종료점
    # i번 상자탑의 오른쪽 => i+1
    # 끝 => N
    # i번 오른쪽에 있는 상자탑의 번호를 j 라고 하자.
    for j in range(i + 1, N):
        # 이 j번 상자탑의 높이가 i번 상자탑보다 높은가?
        if lst[j] >= h:
            # 그렇다면 개수 + 1
            high_count += 1
 
    # i번 상자탑에서의
    # 최대 낙차 구하기
    drop = N - (i + 1) - high_count
 
    # 최대 낙차 비교
    if max_drop < drop:
        max_drop = drop
 
# 반복이 다 끝나면 최대 낙차가 구해져 있다.
print(max_drop)