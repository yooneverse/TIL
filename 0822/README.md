# 트리

- 원소들 간에 계층관계를 가지는 계층형 자료구조이자, `비선형 구조`
  - 비선형 구조는 원소들 간에 1:n 관계를 가짐
- 뒤집어진 나무 모양
- 상위 원소에서 하위 원소로 내려가면서 확장되는 트리(나무) 모양의 구조

###정의
- 한 개 이상의 노드로 이루어진 유한 집합이며 다음 조건을 만족함
    - 노드 중 최상위 노드를 루트(root)라고 함
    - 뻗어나가기 시작하는 것을 가장 아래로부터 본 것인데, 보기 편하도록 옮기면서 뒤집어서 보도록 한 것
    - 즉, 루트에서 잎으로 가도록 하는 구조
    
- 트리는 일부만 잘라내도 트리. 그러나 구분을 위해서 부 트리 혹은 서브 트리라고 함
- 이는 재귀적 의미로 각각 하나의 트리가 됨
```
            A (루트)
         /      |       \
      B(T1)      C(T2)     D(T3)
     / | \         |       / |  \
    E  F  K     G(leaf)   H  I   J
(leaf)(leaf)(leaf)   (leaf)(leaf)(leaf)

```
---

- ○ : 정점(node, vertex)  
- ● : 단말노드(leaf node)

---

### 🎄 트리 용어 정리

- **노드(node)**  
  트리의 원소  


- **간선(edge)**  
  노드를 연결하는 선, 부모 노드와 자식 노드를 연결  


- **루트 노드(root node)**  
  트리의 시작 노드  


- **형제 노드 (sibling node)**  
  같은 부모 노드의 자식 노드들


- **조상 노드**  
  간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들  



- **서브 트리 (subtree)**  
  부모 노드와 연결된 간선을 끊었을 때 생성되는 트리  


- **자손 노드**  
  서브 트리에 있는 하위 레벨의 노드들  
 
  
- **노드의 차수**  
  노드에 연결된 자식 노드의 수  
 


- **트리의 차수**  
  트리에 있는 노드의 차수 중 가장 큰 값  
  - 트리 T의 차수 = 3  


- **단말 노드(리프 노드)**  
  차수가 0인 노드, 즉 자식 노드가 없는 노드  


- **노드의 높이 (레벨)**  
  루트에서 해당 노드까지 이르는 간선의 수  
  - B의 높이 = 1, F의 높이 = 2  


- **트리의 높이**  
  트리에 있는 노드의 높이 중 가장 큰 값 (최대 레벨)  
  - 트리 T의 높이 = 3  

### 차수 != 높이

---

- ○ : 정점(node, vertex)  
- ● : 단말노드(leaf node)

---

# 이진 트리 (Binary Tree)

- 모든 노드가 **최대 2개의 자식 노드**를 가질 수 있는 트리  
  - 자식 노드는 항상 `왼쪽 자식 노드`와 `오른쪽 자식 노드`로 구분  
- 노드가 하나만 있어도 이진 트리로 인정됨 (즉, 트리이자 이진 트리)

---

## 이진 트리의 기본 특성

- **레벨 i에서의 노드 `최대` 개수** = `2^i` 개  
- **높이가 h인 이진 트리의 노드 개수 범위**  
  - 최소 개수 = `h + 1`  
  - 최대 개수 = `2^(h+1) - 1`  
  > ※ 높이 정의(루트 레벨을 0으로 볼지 1로 볼지)에 따라 달라질 수 있으니 기준 확인 필요

---

## 예시 트리 구조 (텍스트 표현)
```
            1 (루트)
           /        \
   2 (부트리 T1)   3 (부트리 T2)
   /    \           /        \
4(leaf) 5(leaf)  6(leaf)   7(leaf)
```
  
> ## 포화 이진 트리 (Full Binary Tree)

- 모든 레벨이 **빈 자리 없이 채워진** 이진 트리  
- 높이가 *h*일 때 **노드 개수** = `2^(h+1) - 1`  
- 루트는 1번으로 시작하며, 모든 노드 번호가 **정해진 위치**에 배정됨

> ## 완전 이진 트리 (Complete Binary Tree)

- **포화 이진 트리의 노드 번호 규칙**을 따름
  - 포화 이진 트리처럼 모든 레벨에 꽉 채워져있지 않아도 되는데 마지막 레벨 마지막 노드까진 채워져야 함
- 마지막 레벨을 제외하고는 모두 노드가 채워져 있음  
- 마지막 레벨에서는 **왼쪽부터 연속된 위치**에 노드가 채워진 형태  
  - 즉, 루트(1번)부터 n번까지 **중간에 빈 번호 없이 순차적으로 존재**
    
> ## 편향 이진 트리(Skewed Binary Tree)

- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리
    

---
### **`오늘의 핵심`**

# 순회 (Traversal)

- 트리의 노드들을 체계적으로 방문하는 것
- 비선형 구조라서 선후 연결 관계 알 수 없음

---

### 3가지의 기본적인 순회 방법

전위, 중위, 후위라고 부르는 기준 → 부모노드가 기준으로 부모노드가 앞이면 전, 중간이면 중, 뒤면 후

1. **전위 순회 (preorder traversal) : VLR**  
   - 부모 노드 방문 후, 왼쪽 자식 노드, 오른쪽 자식 노드 순서로 방문  
   - 예: `부모 → 왼쪽 → 오른쪽`

2. **중위 순회 (inorder traversal) : LVR**  
   - 왼쪽 자식 노드, 부모 노드, 오른쪽 자식 노드 순서로 방문  
   - 예: `왼쪽 → 부모 → 오른쪽`

3. **후위 순회 (postorder traversal) : LRV**  
   - 왼쪽 자식 노드, 오른쪽 자식 노드 방문 후, 부모 노드를 방문  
   - 예: `왼쪽 → 오른쪽 → 부모`

---

## 구조 표현
```
      V (Root)
     /        \
 L (왼쪽)     R (오른쪽)
```
  
# 트리 순회 (Tree Traversal) : 그림과 함께하는 이해과정
** 서술형 출제 가능성 높음

트리의 노드들을 방문하는 방법인 **전위 / 중위 / 후위** 3가지 기본 순회 방식.  
아래 예시는 루트 A를 갖는 트리를 기준으로 설명함.
전부 재귀 형태로 이루어짐

---

## 예시 트리 구조

```text
               A
        /      |       \
       B       C        D
     / | \     |      / | \
    E  F  K    G     H  I  J
```
- 루트: A

- 부트리 T1: B - (E, F, K)

- 부트리 T2: C - (G)

- 부트리 T3: D - (H, I, J)
---
1️⃣ 전위 순회 (Preorder: V → L → R)

```python
def preorder_traverse(T):  # 전위순회
    if T:                  # T is not None
        visit(T)           # print(T.item)
        preorder_traverse(T.left)
        preorder_traverse(T.right)
```

1. 현재 노드 방문 (visit)

2. 왼쪽 서브트리 재귀 호출

3. 오른쪽 서브트리 재귀 호출

- 순서도 규칙:

    V(부모) → L(왼쪽) → R(오른쪽)


- 실제 방문 순서:

    A → B → E → F → K → C → G → D → H → I → J

---
### 라이브 설명
```
     2 (Root)
    /       \
   3          1
             /
            4
```
현재 노드 n을 방문하여 처리 → V

현재 노드 n의 왼쪽 서브트리로 이동 → L

현재 노드 n의 오른쪽 서브트리로 이동 → R

일 때,

V = 1, L = 4, R은 어떻게 표현할까?

----

2️⃣ 중위 순회 (Inorder: L → V → R)

```python
def inorder_traverse(T):   # 중위순회
    if T:                  # T is not None
        inorder_traverse(T.left)
        visit(T)           # print(T.item)
        inorder_traverse(T.right)
```

1. 왼쪽 서브트리 재귀 호출

2. 현재 노드 방문 (visit)

3. 오른쪽 서브트리 재귀 호출

- 순서도 규칙:

    L(왼쪽) → V(부모) → R(오른쪽)


- 실제 방문 순서:

    E → B → F → K → A → G → C → H → D → I → J
---
### 라이브 설명
```
     2 (Root)
    /       \
   3          1
             /
            4
```
`갔는데 없으면 뒷걸음치는 원리`
- 혹시나 있을지 모르니까 가봤다가, 해당하는 게 없으면 다시 돌아가서 V로 돌아가서 처리하고, Right로 가보는 것

---

3️⃣ 후위 순회 (Postorder: L → R → V)

```python
def postorder_traverse(T):   # 후위순회
    if T:                    # T is not None
        postorder_traverse(T.left)
        postorder_traverse(T.right)
        visit(T)             # print(T.item)
```

1. 왼쪽 서브트리 재귀 호출

2. 오른쪽 서브트리 재귀 호출

3. 현재 노드 방문 (visit)

- 순서도 규칙:

    L(왼쪽) → R(오른쪽) → V(부모)


- 실제 방문 순서:

    E → F → K → B → G → C → H → I → J → D → A

### 📊 순회 방식 비교 표

| 순회 방식      | 규칙 (순서도) | 방문 순서 |
|----------------|---------------|-----------|
| 🔵 전위 (Pre)  | V → L → R     | A → B → E → F → K → C → G → D → H → I → J |
| 🟢 중위 (In)   | L → V → R     | E → B → F → K → A → G → C → H → D → I → J |
| 🔴 후위 (Post) | L → R → V     | E → F → K → B → G → C → H → I → J → D → A |

✅ 핵심 정리
```
전위 (Preorder)
→ 부모를 먼저 방문
→ 주로 트리 복사(copy) 작업에 사용
```
```
중위 (Inorder)
→ 왼쪽 → 부모 → 오른쪽
→ 이진 탐색 트리에서 방문 시 정렬된 결과 획득
```
```
후위 (Postorder)
→ 왼쪽 → 오른쪽 → 부모
→ 트리 삭제, 메모리 해제 과정에 활용
```

---

### 배열을 이용한 이진 트리의 표현
- 각 노드 번호를 이진 트리에 부여
- 루트 번호를 1로 함
- 레벨 n에 있는 노드에 대하여 왼쪽부터 오른쪽으로 2^n부터 2^n+1까지 번호 차례대로 부여
* 포화 이진 트리, 완전 이진 트리에 적합: 다른 데 아무렇게나 쓰면 안됨

---

### 🔵 노드 번호의 성질

- 노드 번호가 i인 노드의 부모 노드 번호?  
  ➝ `i // 2`

- 노드 번호가 i인 노드의 왼쪽 자식 노드 번호?  
  ➝ `2 * i`

- 노드 번호가 i인 노드의 오른쪽 자식 노드 번호?  
  ➝ `2 * i + 1`

- 레벨 n의 노드 번호 시작 번호는?  
  ➝ `2^n`


---

### 📌 트리 노드 번호 예시
```
                 1(A)
                /    \
           2(B)        3(C)
          /    \      /    \
      4(D)     5(E)  6(F)   7(G)
     /   \     / 
  8(H)  9(I) 10(J)
```

### 📌 인덱스 관계
E를 기준으로
- 부모 노드 인덱스 = 2  
- 왼쪽 자식 노드 인덱스 = 10  
- 오른쪽 자식 노드 인덱스 = 11

---

* 노드 번호를 배열의 인덱스로 사용
* 높이가 h인 이진 트리를 위한 배열의 크기
    - 레벨 i의 최대 노드 수는 2^i
    
### 배열 인덱스와 노드 매핑

| 인덱스 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|--------|---|---|---|---|---|---|---|---|---|---|----|----|----|----|----|----|
| 노드   | - | A | B | C | D | E | F | G | H | I | J  | -  | -  | -  | -  | -  |

### 부모 번호를 인덱스로, 자식 번호를 저장

###`자식 노드 저장 로직 (부모-자식 입력 기반)`

```python
for i in range(1, N + 1):   # 1 → N까지 반복
    p, c = map(int, input().split())  # 부모 p, 자식 c 읽기

    if c1[p] == 0:   # 아직 첫 번째 자식이 없으면
        c1[p] = c    # 첫 번째 자식으로 저장
    else:            # 이미 첫 번째 자식이 있다면
        c2[p] = c    # 두 번째 자식으로 저장
```

📌 설명:
- `c1[p]`: 부모 `p`의 **왼쪽(첫 번째) 자식**  
- `c2[p]`: 부모 `p`의 **오른쪽(두 번째) 자식**  
- 즉, 이 구조는 **이진 트리**를 배열 두 개(`c1`, `c2`)로 표현하는 방식  
  각각 하나씩 빈 리스트로 부여해서 채워가게 됨. 인덱스가 곧 부모 번호
- 특별한 규칙 없으면 입력 순서대로 L, R 이 채워짐
- 그러나 조건이 주어져서 왼쪽이 오른쪽보다 작아야 한다면 front rear처럼 옮겨가면서 해도 되고, sort해서 차례로 입력해도 됨

### 자식 번호를 인덱스로, 부모 번호를 저장

```python
for i in range(1, N + 1):   # 1 → N까지 반복
    p, c = map(int, input().split())  # 부모 p, 자식 c 읽기

    parent[c] = p  # 자식을 인덱스로, 부모 번호를 저장
```

📌 설명:

- parent[c]: 자식 노드 c의 부모 노드 번호를 저장
- 트리에서 특정 노드의 부모를 찾을 때 유용
- 루트 노드는 부모가 없으므로 parent[root] = 0 또는 None으로 처리
- 이 방식은 c1, c2처럼 자식 중심이 아니라 부모 중심 정보를 바로 접근 가능하게 해줌
- 특별한 규칙 없으면 입력 순서대로 L, R 이 채워짐
- 그러나 조건이 주어져서 왼쪽이 오른쪽보다 작아야 한다면 front rear처럼 옮겨가면서 해도 되고, sort해서 차례로 입력해도 됨

### 루트 찾기 & 조상 찾기

#### 📌 부모 배열 표현
- 자식(`c`)과 부모(`a`)를 배열로 저장
자식(c): 0 1 2 3 4 5
부모(a): 0 0 1 1 3 3
  
#### 📌 트리 구조
```
   1
  / \
 2   3
    / \
   4   5
```

---

## 📌 ex) 5번 노드의 조상 찾기

```python
c = 5
anc = []

while a[c] != 0:     # 루트인지 확인
    c = a[c]         # 부모로 이동
    anc.append(c)    # 조상 목록에 추가

root = c             # 최종 루트 저장
```

- 시작 노드: 5
- 조상 경로: [3, 1]
- 루트: 1

# 단점 적기

---

###수식 트리_연습문제에 등장
- 연산자는 루트 노드이거나 가지 노드
- 피연산자는 모두 잎 노드
- 순회로 전/중/후 나타낼 수 있음





    



