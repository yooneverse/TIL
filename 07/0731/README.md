README



**<OOP2>**



상속

: 한 클래스(부모)의 속성과 메서드를 다른 클래스(자식)가 물려받는 것

클래스 간 상하관계가 형성되며, 위쪽에 있는 부모 클래스가 본인의 속성과 메서드를 넘겨줌



필요한 이유

1. 코드 재사용 (재사용성 높임)

* 상속을 통해 기존 클래스의 속성과 메서드를 재사용할 수 있음
* 기존 클래스를 수정하지 않고도 기능을 확장할 수 있음



2\. 계층 구조

* 상속을 통해 클래스들 간 계층 구조를 형성할 수 있음
* 부모 클래스와 자식 클래스 간 관계를 표현하고, 더 구체적인 클래스를 만들 수 있음



3\. 유지 보수의 용이성

* 상속을 통해 기존 클래스의 수정이 필요한 경우 해당 클래스만 수정하면 되어서 유지보수가 쉬워짐
* 코드 '일관성'을 유지하고 수정이 필요한 범위 최소화 가능

---

공통 속성을 따로 빼고, 상속 속성으로 정의해서 필요한 클래스들이 이 부모 클래스를 물려받아 사용하도록 함

15 슬라이드



---

\# 메서드 오버라이딩



!= 오버로딩

파라미터가 다른 동일한 이름의 여러 메서드를 정의하는 것 (파이썬은 지원하지 않음)

이름이 같으면 마지막으로 선언된 메서드만 인식됨.



심화자료의 메서드 오버라이딩 주의사항 2번 원칙 꼭 숙지하기



---

\# 다중 상속

부모에 A , B 메서드가 있을 때 자식 클래스는 무엇을 상속 받을까



상속 함수의 인자 자리의 작성 순서에 따라 먼저 적힌 것부터 탐색하여 상속받게 되는 것.

약속된 상속 흐름 안에서 받아야 함



* 다이아몬드 문제

&nbsp;	D가 먼저 상속받는 순서대로 갈 것이다. (class D(B, C)면 D -> B -> C 순으로 간다)



MRO : 파이썬이 메서드를 찾는 순서에 대한 규칙 메서드 결정 순서



---



\# super() 함수

MRO(메서드 해석 순서)에 따라, 현재 클래스의 부모(상위) 클래스의 메서드나 속성에 접근하게 해주는 내장 함수

직접 부모 클래스 이름을 쓰지 않아도 자동으로 현재 MRO 순서에 따라 올바른 메서드를 찾아 호출해서 실행할 수 있게 됨



단일 상속에서는 Person.\_\_init\_\_ 메서드 호출과 def \_\_init\_\_을 통해 정의하는 것과 동일

그러나 변동이 발생했을 때, super()로 정리되어 있는 경우 인자 변경을 통한 반영이 쉬움



31 슬라이드 정리 내용으로 다시 보기



뒤에 있는 것을 써야한다면 순서와 상관없이 이루어지도록 직접 쓰면 적용되긴 함



child -> A -> B -> 전역(object class\_조상 클래스)



상황에 따라 순서가 바뀌어 유연한 내장 함수



\*\*MRO가 필요한 이유

: 확장성과 신뢰성



---

\## 에러와 예외



\#디버깅



\*\*버그\*\*



: 소프트웨어에서 발생하는 오류 또는 결함 프로그램의 예상된 동작과 실제 동작 사이의 불일치



디버깅



: 오작동 원인 식별하여 수정



---

에러 유형

1. 문법 에러 : 실행 자체가 안 됨
2. 예외 : 실행 도중에 안 되는 것



예외

: 프로그램 실행 중에 잘못된 동작을 시도할 때 자동 감지



내장예외

: 예외 상황을 나타내는 예외 클래스들



예외 처리

:프로그램이 비정상적으로 종료되지 않고, 적절하게 처리할 수 있도록, 안전하게 이어가게 돕는 법

ex. try, except 구문



try에서 ~한 상황이 벌어지면 except 이하 작업 수행

사용 구문 정리하기



\#try-except 구조



try:

\\# 예외가 발생할 수 있는 코드

except 예외:

\\# 예외 처리 코드



---

else와 finally 구분하기

else는 예외가 없을 때

finally는 어떻게 되든 실행



---

Exception : 모든 예외 (세부의 모든 예외를 포함한 클래스)



상위 클래스일 수록 나중에 확인되도록 해야 함

except 절로 분기 시 반드시 하위 클래스를 먼저 확인할 수 있도록 작성해야 함

즉, 가장 구체적 예외부터 처리하고, 마지막에 범용 예외를 처리하도록 순서 배치



---

예외객체 : 예외에 대한 정보 담고 있는 객체

as 키워드를 통해 전달 가능



try-except와 if-else 함께 사용 가능



---

EAFP / LBYL  각각 동일한 코드를 만들 수 있음

다만, 처리하는 순서가 다름.



LBYL은 조건이 충족되어야만 조회하고 프린트 (안전한지 확인 후 실행)

EAFP은 실행부터 우선 하고, 예외가 발생하면 처리하겠다는 흐름



LBYL - 알고리즘 등 문제 풀이에 사용

EAFP - 백엔드 서버 개발 등 큰 단위 개발에서 사용



---

---

복습

oop



절차 지향 프로그래밍

: 데이터와 함수 분리/호출 흐름이 중요



설계도가 클래스/설계도로 만들어진 게 인스턴스



객체 특징

1. 속성 가짐
2. 메서드 가짐
3. 고유성 가짐



파스칼케이스 : 대문자로 시작해서 구분되는 단어마다 대문자로 첫문자



\_(언더스코어) 두 개가 있으면 특별한 기능 수행



\_ \_ init \_ \_ : 생성자 메서드 => 인스턴스가 만들어질 때, 사용



인스턴스는 어떤 클래스에서 만들어진 인스턴스인지를 반드시 명시해야 함.



self가 있으면 인스턴스 메서드



---

클래스 변수를 조작하거나 ,  클래스 레벨 동작 수행하는 '클래스 메서드'

인스턴스 안에서 변경하기보다 클래스에서 변경하여 반영



66 슬라이드 클래스 메서드 활용 마지막 줄

Person1.population으로 적어도, 인스턴스 안에 population 변수가 없는 이상 Person.population으로 결과 출력



---



모두 같은 값을 참조해야 하는 데이터는 '클래스'로, 각각 달라지는 값을 담는 데이터는 '인스턴스'로















