프로그래밍 패러다임

\- 절차 지향과 객체 지향

\- 객체와 클래스



클래스 기초

\- 클래스

\- 인스턴스

\- 클래스와 인스턴스

\- 클래스 구성요소

\- 클래스 변수와 인스턴스 변수



메서드

\- 인스턴스 메서드

\- 클래스 메서드

\- 스태틱 메서드

\- 메서드 활용

\- 메서드 정리



참고

\- 클래스와 인스턴스 간 이름 공간

\- 매직 메서드

\- 데코레이터



----



절차 지향 프로그래밍

: 함수와 로직 중심 작성 / 데이터를 순차적으로 처리

순서를 따르지 않으면 차례대로 실행되지 않을 수도 있음



데이터랑 함수가 분리되어있음. 함수가 데이터를 재료로서 활용.



---

객체 지향 프로그래밍

: 클래스는 설계도 / 인스턴스는 실제 물건

만들기 위한 설계도 = 클래스

행동 = 메서드

속성

> 속성과 메서드가 설계되어 있음|blueprint 청사진

클래스가 찍어낸 물건이 인스턴스



\- 데이터와 메서드의 결합

\- 프로그램을 변수와 그 데이터를 처리하는 함수(메서드)를 하나의 단위(객체)로 묶어서 조직적으로 관리



---

절차 지향

\- 데이터와 해당 데이터를 처리하는 함수가 분리



객체 지향

\- 데이터와 해당 데이터를 처리하는 메서드를 하나의 객체로 묶음



객체 간 상호작용과 메시지 전달이 중요



절차 지향과 객체 지향은 결코 대조 개념이 아니다.

패러다임 관점





--

객체 : 실제 존재하는 사물을 추상화

클래스: 객체를 만들기 위한 설계도



\- 하나의 구조 안에 데이터(변수)와 기능(함수)을 함께 정의



'생성자 메서드'

\- \_init\_메서드로, 새로운 객체를 만들 때 필요한 초기값을 설정함



---

\# 인스턴스

: 클래스를 사용해 실제로 만들어진 객체

같은 클래스로 여러 인스턴스를 만들 수 있으며,

각 인스턴스는 클래스 구조를 따라 동작하지만 서로 독립된 데이터 가지기 가능



인스턴스는 클래스를 먼저 말해서, 클래스로 인해 만들어진 객체임을 드러내기

'~의 인스턴스인 ..이다'



클래스는 곧 새로운 타입을 만드는 행위를 수행하여 공통된 특성과 기능을 가진 틀을 만드는 것으로 이해하면 됨



oop적 관점에서 변수 name은 str 클래스의 인스턴스라고 부를 수 있음



인스턴스라서 list 안 append 함수로 이끌려 나오는 것이 원리. 





42 슬라이드 오타 정정 문자열 아니고 리스트 타입



---

메서드

: 클래스 내부에 정의된 함수로 해당 객체가 어떻게 동작할지를 정의함

&nbsp; 즉 객체가 할 수 있는 행동을 코드로 표현한 것



1\. 인스턴스 메서드

2\. 클래스 메서드

3\. 스태틱 메서드



---

1\. 인스턴스 메서드

호출 주체 = 인스턴스



클래스 내부에 정의되는 메서드의 기본

**반드시 첫 번째 인자로 인스턴스 자신(self)을 받음, 다른 이름으로 설정가능하나 매개변수 이름으로 'self'를 설정할 것을 강력 권장**

인스턴스의 속성에 접근하거나 변경 가능



왜? 첫번째 인자가 반드시 인스턴스 자기 자신이어야 하는가.

객체 지향 아래 절차 지향이 기본 작동 원리로 깔려있음.



객체.메서드() -> 객체 지향적

&nbsp;            |

str.upper("hello")



첫번째 인자는 로직이 작동할 수 있도록 비워두고, 자기 자신이 들어가도록 해야 함.

그래서 self 쓰고 시작하는 것.



이는 객체 지향 방식의 메서드로 호출하는 단축형 호출 표현이 이루어지고 있었음을 알 수 있다.

객체 스스로 메서드를 호출하여 동작하는 객체 지향적 표현인 것으로, 객체를 재료로 쓰는 것처럼 보이는 것



self.count 등과 같이 하는 것은 호출하는 '그' 함수의 호출 결과를 만들어내는 독립성을 보장하기 위한 것



---

생성자 메서드

: 인스턴스 변수들의 초기값을 설정

인스턴스 객체가 생성될 때 자동으로 호출되는 메서드



여러 인스턴스를 만들 때 초기화를 안 해주면 다른 인스턴스 생성할 때 영향을 주나요?

초기화를 안 한다는 전제는 없고, 표기를 해서 명시를 하도록 하는 것을 추천.



def \_\_init\_\_(self,name):

&nbsp;       self.name = name



확장성의 측면에서도 추천.



class Person:

&nbsp;   # 생성자 메서드

&nbsp;   def \_\_init\_\_(self,name):

&nbsp;       self.name = name

&nbsp;       print("인스턴스가 생성되었습니다.")



&nbsp;   def greeting(self):

&nbsp;       print(f'안녕하세요 {self.name}입니다.')



person1 =Person("지민")

print(person1.name)

person1.greeting()



---



클래스 메서드

: 클래스 변수(공용 속성)를 조작하거나 클래스 레벨의 동작을 수행



데코레이터를 사용하여 정의



self와 동일하게 cls 적용



66슬라이드 @classmethod 박스 -> Person.population +=1



\_\_init\_\_: 안에서 Person.population\_ += 1해도 똑같이 작동할거같은데 클래스 메서드를 써서 설계하는게 더 바람직 하다는걸까요?

사실 똑같지만, 설계와 패러다임 측면에서 보기 때문에, 그렇게 하면 인스턴스 메서드이기에 인스턴스 변수 초기화로 가면 안 됨??



강의 다시 보기!!



---

스태틱(정적) 메서드



: 클래스, 인스턴스와 상관없이 단독으로 동작하는 메서드





@ staticmethod 데코레이터를 사용하여 정의

호출 시 자동으로 전달 받는 인자 없음

자율적이며, helper(도우미) 함수로서의 역할 주로 수행



인스턴스는 인스턴스 하나만

클래스는 클래스와 스태틱 두 개를 다룸
