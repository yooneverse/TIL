```

# 목차



list

- 시퀀스로서의 리스트

- 중첩 리스트

- 리스트의 가변성



tubple

- 시퀀스로서의 튜플

- 튜플의 불변성



range

- range 기본 구문

- range 규칙



dict

- 딕셔너리 규칙

- 딕셔너리 값 접근



set

- 세트의 집합 연산



other types

- None

- Boolean



Collection

-불변과 기변



형변환(type간 변환)

- 암시적 형변환

- 명시적 형변환



연산자

- 산술 연산자

- 복합 연산자

- 비교 연산자

- 논리 연산자

- 단축 연산자

- 멤버십 연산자

- 시퀀스 연산자

- 연산자 우선순위



참고

- Trailing Comma

```



\# 리스트

: 여러 개의 값을 \*\*순서\*\*대로 저장하는, ```변경 가능한``` 시퀀스 자료형



표현법

* 대괄호 \[] 안에 값들을 쉼표(,)로 구분하여 만듦. (여러 개 데이터를 담기 때문)
* 모든 종류의 데이터를 담을 수 있음
* 값을 추가, 수정, 삭제하는 등 자유로운 변경 가능



```

my_list_1 = [] > 빈 리스트

my_list_2 = [1, 'a', 3, 'b', 5]  
> 숫자형과 문자열

my_list_3 = [1, 2, 3,'Python', ['hello', 'world','!!!']] 
> 리스트 안에 리스트 넣을 수 있음

```



\*\*리스트는 시퀀스이므로, 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 기능을 공통으로 모두 사용 가능.\*\*



> 라이브 코드 전체를 직접 타이핑하여 내 것으로 만들기



---

중첩 리스트

: 다른 리스트를 값으로 가진 리스트



\+중첩 : 어떤 자료 구조 안에 같은 종류의 자료 구조가 포함된 형태



\*\*인덱스 속 인덱스의 데이터에 도달하려면 어떻게 해야 할까\*\*

먼저 바깥 리스트의 인덱스로 안쪽 리스트를 선택

선택된 안쪽 리스트에 한 번 더 인덱스를 사용



my\_list = \[1, 2, 3, 'Python', \['hello', 'world', '!!!']]

1단계: print(my\_list\[4]  > \['hello', 'world', '!!!']

2단계: print(my\_list\[4]\[-1])  > !!!

2-1단계: print(my\_list\[-1]\[1]\[0])  > w - 
> 문자열도 엄연한 시퀀스이므로 인덱스로 접근 가능함 잊지 말기



가변성

: 생성된 후에도 그 내용(값)을 변경할 수 있는 성질



리스트는 '가변성'을 가짐. 문자열의 불변성과 정반대인 매우 중요한 특징

즉 한번 생성된 리스트는 '그 내용을 자유롭게 수정, 추가, 삭제할 수 있다'는 뜻



\# 1. 인덱싱으로 값 수정 (하나하나 지칭해서 변경)

my\_list = \[1, 2, 3, 4, 5]

my\_list\[1] = 'two'

print(my\_list)  # \[1, 'two', 3, 4, 5]



\# 2. 슬라이싱으로 값 수정 ( 범위를 지정해서 변경)

my\_list = \[1, 2, 3, 4, 5]

my\_list\[2:4] = \['three', 'four']

print(my\_list)  # \[1, 2, 'three', 'four', 5]



---

\# 튜플

: 여러 개의 값을 순서대로 저장하는, \*\*변경 불가능\*\*한 시퀀스 자료형



\*\*표현법\*\*



* 소괄호 () 안에 값들을 쉼표(,)로 구분하여 만듦
* 모든 종류의 데이터를 담을 수 있음
* 리스트와 거의 모든 면에서 비슷하나, \*\*한번 만들어지면 절대 수정 불가하다\*\*는 결정적 차이 존재
* \*\*소괄호 없이도 만들 수 있음\*\*
* \*\*단일 요소 튜플을 만들 때는 "반드시 Trailing comma (후행 쉼표)를 사용해야 함"



```

my\_tuple\_1 = ()

my\_tuple\_1\_1 = (1) > 튜플이 안됨. 괄호가 벗겨져 버림.

my\_tuple\_2 = (1,) > 1 하나만 들어간 튜플 만드는 법 (후행 쉼표)

my\_tuple\_3 = (1, 'a', 3, 'b', 5)

my\_tuple\_4 = 1, 'hello', 3.14, True > 소괄호 없이도 튜플이 만들어짐

```



튜플 역시 시퀀스이기에 공통 기능을 모두 사용 가능



\*\*튜플의 불변성\*\*

한 번 생성된 튜플은 그 내용을 절대 수정, 추가, 삭제 불가!



> 튜플이 불변 자료형인 이유

* 튜플은 파이썬이 내부 동작을 위해 사용
* 튜플의 불변 특성을 통해 내부 동작과 안전한 데이터 전달에 사용됨. (반드시 해당 데이터에 할당된 값이 전달 되어야 하기 때문)
* 다중 할당, 값 교환, 함수 다중 반환 값 등
* \*\*즉, 튜플은 데이터의 '안정성과 무결성'을 보장\*\*



>  값 교환



x, y = 1, 2

x, y = y, x

\- 실제 내부 동작

\- temp = (y, x)  ```튜플 생성```

\- x, y = temp  ```튜플 언패킹```

\- print(x, y) ``` 2 1```



내부 동작은 안정성이 중요하기 때문에 가변성을 갖는 list는 사용불가한 것.



---

\# range

: \*\*연속된\*\* 정수 시퀀스를 생성하는, 변경 불가능한 자료형



* 주로 반복문과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 유용
* 실제로 모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 '규칙'만 기억하여 효율적 메모리 사용가능



range()는 1개, 2개, 또는 3개의 매개변수(인자)를 가질 수 있음

range(start, stop, step)



인자: 함수 호출할 때, 실제로 전달되는 값

매개변수: 함수를 정의할 때, 함수가 받을 값을 나타내는 변수 = 위 두 개는 함수 챕터에서 자세히 다룸



range(stop)

: 매개변수가 하나면 stop으로 인식

* start는 0이, step은 1이 기본값으로 자동 설정



my\_range\_1 = range(5) =>  0,1,2,3,4

print(my\_range\_1)  => range(0, 5) = 객체 덩어리로서 나옴

list로 변환하거나 자체를 반복문으로 돌려야 함.



range(start,stop)

매개변수가 두 개면 start와 stop으로 인식

step은 1이 기본값으로 자동 설정



my\_range\_2 = range(1,10) '''0,1,2,3,4,5,6,7,8,9```

print(my\_range\_2)  => range(1, 10)



range(start,stop,step)

모든 매개변수를 직접 지정



my\_range\_3 = range(5,0,-1)

print(my\_range\_3)  => range(5, 0, -1)



모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 '규칙'만 기억하여 메모리 효율적으로 사용



1. 값의 범위 규칙
2. 증가/감소/값(step) 규칙

* step 값은 숫자 시퀀스의 간격과방향을 결정



\\# step이 양수일 때 (기본값 1)

\\# 시작 값이 끝 값보다 작은 경우 (정상)

print(list(range(1, 5)))  \\# \[1, 2, 3, 4]

\\# 시작 값이 끝 값보다 큰 경우

print(list(range(5, 1)))  # \[] => 출력되지 않음



\\# step이 음수일 때

\\# 시작 값이 끝 값보다 큰 경우 (정상)

print(list(range(5, 1, -1)))  \\# \[5, 4, 3, 2]

\\# 시작 값이 끝 값보다 작은 경우

print(list(range(1, 5, -1))) \\# \[]



---

\# dict (딕셔너리)

:key-value 쌍으로 이루어진 순서와 중복이 없는 변경 가능한 자료형 

=> 쌍을 지은 것이 값 '하나' 

=>비시퀀스 (순서가 없음) = 인덱스가 없음, key로 바로 접근해서 데이터 추출



\*\*표현법\*\*

* 중괄호 { } 안에 값들이 쉼표(,)로 구분되어 있음
* 값 1개는 키와 같이 쌍으로 이루어져 있음
* Key(키) : 값을 식별하기 위한 고유한 '이름표' (중복불가)
* Value(값) : 키에 해당하는 실제 데이터
* 각 값에 순서가 없음



my\_dict\_1 = {}

my\_dict\_2 = ('key', 'value')

my\_dict\_3 = {'apple': 12, "list" : \[1,2,3]}



print(my\_dict\_1) \\# {}

print(my\_dict\_2)  \\# {'key': 'value'}

print(my\_dict\_3)  \\# {'apple': 12, 'list': \[1, 2, 3]} 



=> 순서가 없음을 알기, 그러나 파이썬 3.7 이상에서는 입력 순서가 출력 시 그대로 유지되고 보장 (원활한 개발을 위해)

그렇다고 순서가 생긴 건 아님.



---

딕서녀리 규칙



\*\*Key 규칙\*\*

* 고유해야 함 (Key는 중복될 수 없음)
* 변경 불가능한 자료형만 사용 가능
* O(가능) : str, int, float, tuple / X(불가능) : list, dict



\*\*Value의 규칙\*\*

* 어떤 자료형이든 자유롭게 사용할 수 있음



\*\*딕셔너리 값 접근법\*\*

* key 사용하여 해당 value 꺼내올 수 있음
* key에 접근 시 대괄호 \[ ] 사용



my\_dict = {'name': '홍길동', 'age': 25}

print(my\_dict\['name'])  \\# '홍길동'

print(my\_dict\['test'])  \\# KeyError: 'test'



