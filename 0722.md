```

# 목차



list

- 시퀀스로서의 리스트

- 중첩 리스트

- 리스트의 가변성



tubple

- 시퀀스로서의 튜플

- 튜플의 불변성



range

- range 기본 구문

- range 규칙



dict

- 딕셔너리 규칙

- 딕셔너리 값 접근



set

- 세트의 집합 연산



other types

- None

- Boolean



Collection

-불변과 기변



형변환(type간 변환)

- 암시적 형변환

- 명시적 형변환



연산자

- 산술 연산자

- 복합 연산자

- 비교 연산자

- 논리 연산자

- 단축 연산자

- 멤버십 연산자

- 시퀀스 연산자

- 연산자 우선순위



참고

- Trailing Comma

```



\# 리스트

: 여러 개의 값을 \*\*순서\*\*대로 저장하는, ```변경 가능한``` 시퀀스 자료형



표현법

* 대괄호 \[] 안에 값들을 쉼표(,)로 구분하여 만듦. (여러 개 데이터를 담기 때문)
* 모든 종류의 데이터를 담을 수 있음
* 값을 추가, 수정, 삭제하는 등 자유로운 변경 가능



```

my_list_1 = [] > 빈 리스트

my_list_2 = [1, 'a', 3, 'b', 5]  
> 숫자형과 문자열

my_list_3 = [1, 2, 3,'Python', ['hello', 'world','!!!']] 
> 리스트 안에 리스트 넣을 수 있음

```



\*\*리스트는 시퀀스이므로, 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 기능을 공통으로 모두 사용 가능.\*\*



> 라이브 코드 전체를 직접 타이핑하여 내 것으로 만들기



---

중첩 리스트

: 다른 리스트를 값으로 가진 리스트



\+중첩 : 어떤 자료 구조 안에 같은 종류의 자료 구조가 포함된 형태



\*\*인덱스 속 인덱스의 데이터에 도달하려면 어떻게 해야 할까\*\*

먼저 바깥 리스트의 인덱스로 안쪽 리스트를 선택

선택된 안쪽 리스트에 한 번 더 인덱스를 사용



my\_list = \[1, 2, 3, 'Python', \['hello', 'world', '!!!']]

1단계: print(my\_list\[4]  > \['hello', 'world', '!!!']

2단계: print(my\_list\[4]\[-1])  > !!!

2-1단계: print(my\_list\[-1]\[1]\[0])  > w - 
> 문자열도 엄연한 시퀀스이므로 인덱스로 접근 가능함 잊지 말기



가변성

: 생성된 후에도 그 내용(값)을 변경할 수 있는 성질



리스트는 '가변성'을 가짐. 문자열의 불변성과 정반대인 매우 중요한 특징

즉 한번 생성된 리스트는 '그 내용을 자유롭게 수정, 추가, 삭제할 수 있다'는 뜻



\# 1. 인덱싱으로 값 수정 (하나하나 지칭해서 변경)

my\_list = \[1, 2, 3, 4, 5]

my\_list\[1] = 'two'

print(my\_list)  # \[1, 'two', 3, 4, 5]



\# 2. 슬라이싱으로 값 수정 ( 범위를 지정해서 변경)

my\_list = \[1, 2, 3, 4, 5]

my\_list\[2:4] = \['three', 'four']

print(my\_list)  # \[1, 2, 'three', 'four', 5]



---

# 튜플

: 여러 개의 값을 순서대로 저장하는, \*\*변경 불가능\*\*한 시퀀스 자료형



**표현법**



* 소괄호 () 안에 값들을 쉼표(,)로 구분하여 만듦
* 모든 종류의 데이터를 담을 수 있음
* 리스트와 거의 모든 면에서 비슷하나, \*\*한번 만들어지면 절대 수정 불가하다\*\*는 결정적 차이 존재
* \*\*소괄호 없이도 만들 수 있음\*\*
* \*\*단일 요소 튜플을 만들 때는 "반드시 Trailing comma (후행 쉼표)를 사용해야 함"



```

my\_tuple\_1 = ()

my\_tuple\_1\_1 = (1) > 튜플이 안됨. 괄호가 벗겨져 버림.

my\_tuple\_2 = (1,) > 1 하나만 들어간 튜플 만드는 법 (후행 쉼표)

my\_tuple\_3 = (1, 'a', 3, 'b', 5)

my\_tuple\_4 = 1, 'hello', 3.14, True > 소괄호 없이도 튜플이 만들어짐

```



튜플 역시 시퀀스이기에 공통 기능을 모두 사용 가능



\*\*튜플의 불변성\*\*

한 번 생성된 튜플은 그 내용을 절대 수정, 추가, 삭제 불가!



> 튜플이 불변 자료형인 이유

* 튜플은 파이썬이 내부 동작을 위해 사용
* 튜플의 불변 특성을 통해 내부 동작과 안전한 데이터 전달에 사용됨. (반드시 해당 데이터에 할당된 값이 전달 되어야 하기 때문)
* 다중 할당, 값 교환, 함수 다중 반환 값 등
* \*\*즉, 튜플은 데이터의 '안정성과 무결성'을 보장\*\*



>  값 교환

x, y = 1, 2

x, y = y, x

\- 실제 내부 동작

\- temp = (y, x)  ```튜플 생성```

\- x, y = temp  ```튜플 언패킹```

\- print(x, y) ``` 2 1```



내부 동작은 안정성이 중요하기 때문에 가변성을 갖는 list는 사용불가한 것.



---

# range

: \*\*연속된\*\* 정수 시퀀스를 생성하는, 변경 불가능한 자료형



* 주로 반복문과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 유용
* 실제로 모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 '규칙'만 기억하여 효율적 메모리 사용가능
* range는 숫자를 만들어주는 함수 개념 **추후 자세히 다룸



range()는 1개, 2개, 또는 3개의 매개변수(인자)를 가질 수 있음

range(start, stop, step)



인자: 함수 호출할 때, 실제로 전달되는 값

매개변수: 함수를 정의할 때, 함수가 받을 값을 나타내는 변수 = 위 두 개는 함수 챕터에서 자세히 다룸



range(stop)

: 매개변수가 하나면 stop으로 인식

* start는 0이, step은 1이 기본값으로 자동 설정



my\_range\_1 = range(5) =>  0,1,2,3,4

print(my\_range\_1)  => range(0, 5) = 객체 덩어리로서 나옴

list로 변환하거나 자체를 반복문으로 돌려야 함.



range(start,stop)

매개변수가 두 개면 start와 stop으로 인식

step은 1이 기본값으로 자동 설정



my\_range\_2 = range(1,10) '''0,1,2,3,4,5,6,7,8,9```

print(my\_range\_2)  => range(1, 10)



range(start,stop,step)

모든 매개변수를 직접 지정


my\_range\_3 = range(5,0,-1)

print(my\_range\_3)  => range(5, 0, -1)



모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 '규칙'만 기억하여 메모리 효율적으로 사용



1. 값의 범위 규칙
2. 증가/감소/값(step) 규칙

* step 값은 숫자 시퀀스의 간격과방향을 결정



\\# step이 양수일 때 (기본값 1)

\\# 시작 값이 끝 값보다 작은 경우 (정상)

print(list(range(1, 5)))  \\# \[1, 2, 3, 4]

\\# 시작 값이 끝 값보다 큰 경우

print(list(range(5, 1)))  # \[] => 출력되지 않음



\\# step이 음수일 때

\\# 시작 값이 끝 값보다 큰 경우 (정상)

print(list(range(5, 1, -1)))  \\# \[5, 4, 3, 2]

\\# 시작 값이 끝 값보다 작은 경우

print(list(range(1, 5, -1))) \\# \[]



---

# dict (딕셔너리)

:key-value 쌍으로 이루어진 순서와 중복이 없는 변경 가능한 자료형 

=> 쌍을 지은 것이 값 '하나' 

=>비시퀀스 (순서가 없음) = 인덱스가 없음, key로 바로 접근해서 데이터 추출



\*\*표현법\*\*

* 중괄호 { } 안에 값들이 쉼표(,)로 구분되어 있음
* 값 1개는 키와 같이 쌍으로 이루어져 있음 (가운데 :(콜론) 으로, 왼쪽이 키고 오른쪽이 값)
* Key(키) : 값을 식별하기 위한 고유한 '이름표' (중복불가)
* Value(값) : 키에 해당하는 실제 데이터 (중복가능)
* 각 값에 순서가 없음 (인덱스가 없음)



my\_dict\_1 = {}

my\_dict\_2 = ('key', 'value')

my\_dict\_3 = {'apple': 12, "list" : \[1,2,3]}



print(my\_dict\_1) \\# {}

print(my\_dict\_2)  \\# {'key': 'value'}

print(my\_dict\_3)  \\# {'apple': 12, 'list': \[1, 2, 3]} 



=> 순서가 없음을 알기, 그러나 파이썬 3.7 이상에서는 입력 순서가 출력 시 그대로 유지되고 보장 (원활한 개발을 위해)

그렇다고 순서가 생긴 건 아님.



---

딕서녀리 규칙



\*\*Key 규칙\*\*

* 고유해야 함 (Key는 중복될 수 없음)
* 변경 불가능한 자료형만 사용 가능
* O(가능) : str, int, float, tuple / X(불가능) : list, dict



\*\*Value의 규칙\*\*

* 어떤 자료형이든 자유롭게 사용할 수 있음



\*\*딕셔너리 값 접근법\*\*

* key 사용하여 해당 value 꺼내올 수 있음
* key에 접근 시 대괄호 \[ ] 사용
* 존재하지 않는 Key로 접근하면 KeyError가 발생하며 프로그램이 멈춤
* 사전에서 단어를 찾아 뜻을 확인하는 것처럼, 딕셔너리는 Key를 통해 Value에 빠르게 접근


my\_dict = {'name': '홍길동', 'age': 25}

print(my\_dict\['name'])  \# '홍길동'

print(my\_dict\['test'])  \# KeyError: 'test'

'가변'이 Key를 바꿀 수 있다는 것이 아니라(Key는 불변), 값을 바꿀 수 있다는 것.

\# 딕셔너리 값 추가 및 변경
my_dict = {'apple': 12, 'list': [1, 2, 3]}
\# 추가
- 의미 있는 Key가 필요한 경우, API와 접목하여 인적 정보 등을 불러오기 위해 사용
my_dict['banana'] = 50
print(my_dict)  # {'apple': 12, 'list': [1, 2, 3], 'banana': 50}

\# 변경
my_dict['apple'] = 100
print(my_dict)  # {'apple': 100, 'list': [1, 2, 3], 'banana': 50}

---
# Set
: 순서와 중복이 없는, 변경 가능한 자료형 ("키-값" 쌍으로 되어있지 않은 것이 딕셔너리와의 차이점)

**표현법**

중괄호 {} 안에 값들을 쉼표(,)로 구분해서 만듦

my_set_1 = set()
my_set_2 = {1,2,3}
my_set_3 = {1,1,1}

튜플과 비슷한 위치, 수학에서의 집합 연산을 수행함.

비어있는 딕셔너리와의 혼동을 피하기 위해, 비어 있는 세트는 반드시 set() 함수로 만들어야 함.

| = 합집합 기호

\# 세트의 집합 연산산
my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}

\# 합집합
print(my_set_1 | my_set_2)  # {1, 2, 3, 6, 9}

\# 차집합
print(my_set_1 - my_set_2)  # {1, 2}

\# 교집합
print(my_set_1 & my_set_2)  # {3}

= 수학의 집합 개념을 그대로 가져와, 두 데이터 그룹 간 관계를 파악하는 데에 효과적으로 사용.

---
Other Types

# None

- '값을 없음'을 표현하는 특별한 데이터 타입
- 내용물이 없는 빈 상자로서, 무의 존재와는 다름
- 숫자 0이나 빈 문자열('')과는 다른, '값이 존재하지 않음' 또는 '아직 정해지지 않음'이라는 상태를 나타내기 위해 사용
- 'N'one 으로 적어야 함. 첫 N은 무조건 대문자!

my_variable = None
print(my_variable)  \# None

# Boolean
: 참과 거짓, 단 두 가지 값만 가지는 데이터 타입

온오프 스위치처럼, 프로그램 흐름을 제어하는 조건문에서 맞다/틀리다를 판단
비교/논리 연산의 평가 결과로 사용되며, True와 False의 첫 문자는 무조건 대문자
주로 조건/반복문과 사용

\# Boolean
is_active = True
is_logged_in = False

print(is_active)  \# True
print(is_logged_in)  \# False
print(10 > 5)  \# True
print(10 == 5)  \# False

---
# Collection
: 여러 개의 값을 하나로 묶어 관리하는 자료형들을 통칭하는 말
```str, list, tuple, range, set, dict 데이터 타입을 통칭.```

61 슬라이드 정리하기

# 불변과 가변

불변
: 변경 불가, 안정성, 예측 가능
ex. str, tuple, range

가변
: 변경 가능, 유연성, 효율성, 불안정(내부 작동에 못 씀)
ex. list, dict, set

\# immutable (불변)
my_str = 'hello'
my_str[0] = 'z'  # TypeError: 'str' object does not support item assignment

\# mutable (가변)
my_list = [1, 2, 3]
my_list[0] = 100
print(my_list)  \# [100, 2, 3]

> '가변' 이해를 위해 얕은 복사와 깊은 복사의 개념 찾아보기


---
# 형변환
: 한 데이터 타입을 다른 데이터 타입으로 '필요에 따라' '형태를' 변환하는 과정

2가지 종류
1. 암시적 형변환 : 파이썬이 자동 처리
2. 명시적 형변환 : 개발자가 직접 지시

암시적 형변환
:파이썬이 연산 중에 자동으로 데이터 타입 변환

파이썬이 데이터 손실 막기 위해 더 정밀한 타입으로 자동 변환하는 규칙
'더 안전한 쪽으로(데이터 손실이 적은 쪽으로)' 파이썬이 처리하며, 정수와 실수 중 실수를 선택하는 경우
불리언은 0과 1이므로 불리언의 (True+False)덧셈 결과는 1. 

\# 암시적 형변환
\# 정수(int)와 실수(float)의 덧셈
print(3 + 5.0)  # 8.0
\# 불리언(bool)과 정수(int)의 덧셈
print(True + 3)  # 4
\# 불리언간의 덧셈
print(True + False)  # 1

True는 1, False는 0

명시적 형변환
:개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환

서로 다른 타입 데이터를 '호환'되도록 맞추는 과정
'어댑터'를 끼우는 것과 동일하게 작용한다고 이해하면 됨
파이썬은 타입에 엄격

\# 명시적 형변환
\# str -> int (형식에 맞는 숫자만 가능)
print(int('1'))  \# 1
\# ValueError: invalid literal for int() with base 10: '3.5'
\# print(int('3.5'))
print(int(3.5))  \# 3
print(float('3.5'))  \# 3.5

\# int -> str(모두 가능)
print(str(1) + '등')  \# 1등

---
# 연산자

**산술연산자**
: 수학적 계산을 위해 사용되는 연산자

**복합연산자** 80 페이지 표 정리하기
연산과 할당이 함께 이뤄짐
파이썬은 명시적인 것을 좋아하기에, 의미와 연산자를 오가면서 연습하기

+= : a = a + b 를 의미함
-= : a = a - b    ''
...추후 추가

\# 복합 연산자
y = 10
y -= 4
\# y = y - 4
print(y)  \# 6

z = 7
z *= 2
print(z)  \# 14

w = 15
w /= 4
print(w)  \# 3.75

q = 20
q //= 3
print(q)  \# 6

**비교연산자**
두 값을 비교하여 그 관계가 맞는지 틀린지를 True 또는 False로 반환

'!' = not

83 슬라이드 정리

== (equality) 연산자
- 값(데이터)이 같은지를 비교
- 동등성
- 1 == True의 경우 파이썬이 내부적으로 True를 1로 간주할 수 있으므로 True 결과가 나옴

is 연산자
- 객체 자체가 같은지를 비교
- 식별성
- 두 변수가 완전히 동일한 객체를 가리키는지, 즉 메모리 주소가 같은지를 확인할 때 사용

\# == 연산자
print(2 == 2.0)  \# True
print(2 != 2)  \# False
print('HI' == 'hi')  \# False
print(1 == True)  \# True

\# is 연산자
\# SyntaxWarning: "is" with a literal. Did you mean "=="?
print(1 is True)  \# False
print(2 is 2.0)  \# False

**is 대신 ==를 사용해야 하는 이유**

> is는 '정체성'을 비교하고, ==는 '가치(값)'를 비교하기 때문
> 두 연산자는 "같다"를 확인하는 목적이 근본적으로 다름
- is : 두 변수가 완전히 동일한 메모리 주소의 객체를 가리키는지를 식별해, 값 비교에 사용하면 의도와 다른 결과를 낳을 수 있음

\# 왜 is 대신 ==를 사용해야 하나?
\# 1(정수)과 True(불리언)는 다른 객체이다.
print(1 is True)  \# False
\# 1과 True의 '값'은 논리적으로 같다.
print(1 == True)  \# True

\# 2(정수)와 2.0(실수)은 다른 객체이다.
print(2 is 2.0)  \# False
\# 2와 2.0의 '값'은 논리적으로 같다.
print(2 == 2.0)  \# True

is 연산자는 언제 사용하는가?
\# 싱글턴 객체 비교할 때
x = None
\# 권장
if x is None:
    print('x는 None입니다.')
\# 비권장
if x == None:
    print('x는 None입니다.')


x = True
y = True
print(x is y)  \# True
print(True is True)  \# True
print(False is False)  \# True
print(None is None)  \# True

프로그램 전체에서 오직 1개만 존재하도록 만들어진 특별한 객체인 None, True, False가 싱글턴 객체로 불림. 단 하나의 객체만 생성되어 재사용.

- 리스트 또는 다른 가변 객체를 비교할 대, 값 자체가 같은지 확인하려면 == 사용
- 두 변수가 완전히 동이한 객체를 가리키는지 확인해야 한다면 is 사용

\# 리스트나 객체 비교 시 주의사항
a = [1, 2, 3]
b = [1, 2, 3]
print(a == b) \# True (두 리스트의 값은 동일)
print(a is b) \# False (서로 다른 리스트 객체)

\# b가 a를 그대로 참조하도록 할 경우
b = a
print(a is b) \# True (같은 객체를 가리키므로 True)

**정리**
값 비교에는 ==를 사용, 객체(레퍼런스) 비교에는 is 사용이 원칙
동등성(값)을 판단해야 할 때 is 사용하면 의도치 않은 결과(False)가 나올 수 있으며, 파이썬 내부적 최적화나 타입 차이로 인해 일관성이 깨질 수 있음
is는 주로 싱글턴 객체 비교 시 사용

---
**논리 연산자**
: 여러 개 조건을 조합하거나 값을 반대로 뒤집을 때 사용

92 슬라이드

**단축 평가**
파이썬은 앞쪽에서 결과가 확정되어 버리면 뒤를 버림('단축'하고 지나감)
: 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작

* 거짓으로 취급되는 값들
- False, 숫자 0, 빈 문자열 " ",  빈 리스트 [], None 등 '비어있거나 없다'는 값들

*참으로 취급되는 값들
- True와 '거짓'이 아닌 모든 값
- 내용이 있는 값

\# 1
\# 준비물 1: 내용이 있는 문자열
item1 = '지도'
\# 준비물 2: 내용이 있는 문자열
item2 = '나침반'
result = item1 and item2
print(f'최종적으로 챙긴 물건: {result}')
\# >> 최종적으로 챙긴 물건: 나침반

\# 2
item1 = '지도'
\# 준비물 2: 내용이 없는 빈 문자열
item2 = ''
result = item1 and item2
print(f'최종적으로 챙긴 물건: "{result}"')
\# >> 최종적으로 챙긴 물건: False

\# 3
\# 준비물 1: 내용이 없는 빈 문자열
\# and는 item1을 보자마자 '탈락!'을 외치며 평가를 종료하여 그 자리에서 ''를 최종 결과로 선택하고 item2는 쳐다보지도 않음
item1 = ''
item2 = '나침반'
result = item1 and item2
print(f'최종적으로 챙긴 물건: "{result}"')
\# >> 최종적으로 챙긴 물건: ''

**멤버십 연산자**
특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자
in/not_in

\# 멤버십 연산자

word = 'hello'
numbers = [1, 2, 3, 4, 5]

print('h' in word)  # True

print('z' in word)  # False

print(4 not in numbers)  \# False
print(6 not in numbers)  \# True

**시퀀스형 연산자**
시퀀스 자료형에 특별한 의미로 사용되는 연산자로서, '+'는 시퀀스를 연결하여 '결합'하는 기능을, '*'는 시퀀스를 '반복'하는 기능을 함

print('Gildong' + ' Hong')  \# Gildong Hong
print('hi' * 5)  \# hihihihihi

print([1, 2] + ['a', 'b'])  \# [1, 2, 'a', 'b']
print([1, 2] * 2)  \# [1, 2, 1, 2]

# 연산자 우선순위 정리
![alt text](image-2.png)

---
# Trailing Comma
: 컬렉션의 마지막 요소 뒤에 붙는 쉼표
일반적으로 선택사항이나, 하나의 요소로 구성된 튜플을 만들 때만, 필수

기본 규칙
- 각 요소를 별도 줄에 작성
- 마지막 요소 뒤에 Trailing comma 추가
- 닫는 괄호는 새로운 줄에 배치
- 딕셔너리에서 많이 씀

113 슬라이드 기반 정리할 것

장점
1. 가독성 향상
   - 각 줄이 동일한 패턴 가짐
   - 코드 리뷰 용이
  
2. 유지보수 용이성
   - 항목 추가/제거 간단
   - 실수로 인한 구문 오류 방지

---
* 추가 공부
  
변경 = 주소 유지, 내용만 바꾸기
(재)할당 = 내용이 바뀌면서 주소도 바뀌는 경우. 즉, 변수가 가리키는 객체를 다른 개체로 바꾸기

[ ] = 닫힌 범위
( ) = 열린 범위