# T = int(input())
#
# for tc in range(1, T+1):
#     #원소의 개수는 10개
#     N = 10
#
#     #원소 합이 0인 부분집합 개수
#     count_0 = 0
#
#     #10개의 정수
#     numbers = list(map(int, input().split()))
#
#     # 원소의 개수가 N개인 집합의 부분집합 개수는 2**N == 1<<N
#     # 모든 부분집합을 다 한번식 만들어 보고 합이 0이 되는지 확인
#     # 부분집합의 개수만큼 반복(2의 N제곱)
#     for i in range(1 << N):
#         # i를 부분집합의 번호(인덱스) 라고 생각하자
#         # i를 이진수로 바꿔서 생각
#         # 이진수의 각 자릿수는 0 또는 1
#         # 이진수의 어떤 자릿수에 1이 있는 경우 => 그 자리(인덱스)에 있는 원소를 부분집합에 포함
#         # 이진수의 어떤 자릿수에 0이 있는 경우 => 그 자리(인덱스)에 있는 원소는 포함하지 않음
#
#         # 어떤 자릿수에 1이 있는지 없는지 어떻게 알아내지??
#         # 비트 연산자 '&' 사용 (True and True === True///// 1&1 === 1)
#         # 11110001
#         #        &
#         # 00000001
#         # --------
#         #        1 ==> 1과 비교했을 때 결과가 1 => 1을 왼쪽으로 0번 밀었을 대 1이 있음 -> 0번 원소는 부분집합에 포함
#         # 11110001
#         #        &
#         # 00000010
#         # --------
#         #       10 ==> 1 0 과 비교했을 때 결과가 0 => 1을 왼쪽으로 1번 밀었을 때 1이 없음 -> 1번 원소는 부분집합에 미포함
#
#         #...
#
#         # 11110001
#         #        &
#         # 10000000
#         # --------
#         # 10000000 ==> 비교했을 때 결과가 0이 아님 => 1을 왼쪽으로 7번 밀었을 때 1이 있음 -> 7번 원소는 부분집합에 포함
#
#         # 밀은 횟수 == 시프트한 횟수 == j
#         for j in range(N):
#             # 이진수 1을 왼쪽으로 최대 N-1번까지 밀어보면서(시프트) 확인
#             # j번 비트
#             if i & (1<<j):
#                 # 부분집합의 인덱스 번호 i를 이진수로 생각하고 1을 왼쪽으로 j번 시프트한 결과와 & 연산
#                 # 결과가 0이다 => j번 원소는 부분집합에 미포함
#                 # 결과가 0이 아니다 => j번 원소는 부분집합에 포함 (0 외 모든 숫자가 True)
#                 # 현재 i번 부분집합에는 numbers[j] => 부분집합에 포함이 되어 있음!!
#                 ith_subset_sum += numbers[j]
#                 ith_subset.append(numbers[j]
#
#              # 모든 비트를 다 검사하고 나면 부분집합 완성
#             if ith_subset_sum == 0:
#                 print(ith_subset)
#                 #부분집합의 합이 0이 되는 경우의 수
#                 count_0 += 1
#
#         print(f"{tc} {count_0}")

for tc in range(1, T+1):

    P, A, B = map(int, input().split())

    winner=""

    A_s, A_e = 1,P # A가 이진탐색하는 범위
    B_s, B_e = 1,P # B가 이진탐색하는 범위

    # 일단 무한 반복하다가 승리자가 결정되면 반복 중단
    while True:
        # A가 목표 페이지를 찾았는지 여부를 나타내는 변수
        A_find = False
        # B가 목표 페이지를 찾았는지 여부를 나타내는 변수
        B_find = False

        # A 탐색
        mid = (A_s + A_e) // 2

        if mid == A:
            #목표 페이지를 찾음
            A_find = True
        elif mid > A:
            A-e = mid # 여기 주의 (문제는 다름)
        else:
            A_s = mid

        #B 탐색
        mid = (B_s + B_e) // 2

        if mid == B:
            B_find = True
        elif mid > B:
            B_e = mid
        else:
            B_s = mid

        #누가 찾았나??


        #A,B 모두 찾은 경우
        if A_find and B_find:
            winner = 0
            break

        #A가 찾은 경우
        if A_find:
            winner = "A"
            break

        #B가 찾은 경우
        if B_find:
            winner = "B"
            break

            #조건 범위가 좁은 걸 위로 써줘야 함

    print(f"{tc} {winner}")